
==============================
Quickstart with ``virtualenv``
==============================

Installation
============

To start, install |virtualenv|_ and create a virtual environment for our
experiments.

.. class:: handout

    I prefer zc.buildout for production deployments, but virtualenv is very
    nice for quick experimentation.

::

    $ easy_install virtualenv
    $ virtualenv quickstart

Install zc.async in the virtual environment.

::

    $ cd quickstart/
    $ ./bin/easy_install zc.async

.. |virtualenv| replace:: ``virtualenv``

.. _virtualenv: http://pypi.python.org/pypi/virtualenv

Dependencies
============

This installed several packages.

- the ZODB, an object database from the Zope project;

- Twisted, a framework for networked applications;

- the component architecture from the Zope project;

- and a few smaller packages.

All of these, and zc.async, are distributed under BSD-like licenses such as
LGPL and ZPL.

.. class:: handout

    ::

        $ ls lib/python2.5/site-packages/
        Twisted-8.1.0-py2.5-macosx-10.5-i386.egg
        ZConfig-2.5.1-py2.5.egg
        ZODB3-3.8.1b5-py2.5-macosx-10.5-i386.egg
        easy-install.pth
        pytz-2008c-py2.5.egg
        rwproperty-1.0-py2.5.egg
        setuptools-0.6c8-py2.5.egg
        setuptools.pth
        uuid-1.30-py2.5.egg
        zc.async-1.4.0-py2.5.egg
        zc.dict-1.2.1-py2.5.egg
        zc.queue-1.1-py2.5.egg
        zc.twist-1.3-py2.5-macosx-10.5-i386.egg
        zdaemon-2.0.2-py2.5.egg
        zope.bforest-1.2-py2.5.egg
        zope.component-3.4.0-py2.5.egg
        zope.deferredimport-3.4.0-py2.5.egg
        zope.deprecation-3.4.0-py2.5.egg
        zope.event-3.4.0-py2.5.egg
        zope.i18nmessageid-3.4.3-py2.5-macosx-10.5-i386.egg
        zope.interface-3.4.1-py2.5-macosx-10.5-i386.egg
        zope.minmax-1.1.0-py2.5.egg
        zope.proxy-3.4.1-py2.5-macosx-10.5-i386.egg
        zope.testing-3.6.0-py2.5.egg

ZEO Server
==========

zc.async relies on a distributed ZODB technology called ZEO ("Zope Enterprise
Objects") to distribute work. ZEO has a central database server to which client
processes connect.

Let's start the ZEO Server::

    $ ./bin/runzeo -a 9999 -f test.fs &

That starts a database server, accessible on port 9999 of your local machine,
saving the data in the test.fs file.

A Client
========

Now let's start a Python with a client connection to the database server.

Start up ``bin/python`` (not your system python, but the one in virtualenv's
``quickstart/bin``)::

    $ ./bin/python

This will be our single client process.

You might have many, each connecting to the main database server, and each able
to perform and/or request zc.async jobs.

Database Connection
===================

Connect to the database.

::

    >>  import ZEO.ClientStorage
    >>  import ZODB
    >>  storage = ZEO.ClientStorage.ClientStorage(
    ...     ('127.0.0.1', 9999))
    >>  db = ZODB.DB(storage)

.. When run as a doctest, this uses a simple FileStorage, rather than a
   ClientStorage.

    >>> import ZODB.FileStorage
    >>> storage = ZODB.FileStorage.FileStorage(
    ...     'zc_async.fs', create=True)
    >>> from ZODB.DB import DB
    >>> db = DB(storage)

Start zc.async: Basics
======================

Now we do some basic configuration.  This first bit installs some default
adapters.  You might not ever have to worry too much about them.

    >>> import zc.async.configure
    >>> zc.async.configure.base()

Start zc.async: Policy
======================

This second part is policy, and if you ever put zc.async in production, you'll
want to understand what's going on here.  We'll talk about what's going on here
a little later.

    >>> zc.async.configure.start(
    ...     db, poll_interval=1)

Now the system has a ``dispatcher`` polling for jobs every second.

The Queue
=========

The ``start`` function also installed a queue.  To get zc.async to do work, you
put a job in a queue, and commit the transaction.

First, let's get the queue that we have installed.  We need to open a
connection to the database.  Then we get the queue.

    >>> conn = db.open()
    >>> import zc.async.interfaces
    >>> q = zc.async.interfaces.IQueue(conn)

A Job
=====

Let's put a job in our queue.  This silly example will return the current time.

    >>> import time
    >>> j = q.put(time.time)

It's not done yet.

    >>> j.result
    >>> j.status
    u'pending-status'

.. class:: handout

    This is a silly example. Imagine instead that this was some really
    long-running job. Maybe you have lots of these jobs coming in, and you need
    to have many machines to claim jobs and perform them, so that you can
    scale. Maybe this job divides itself up into parallel or serial jobs, and
    this parent job isn't done until all the children jobs run to completion.

    Or maybe this is a silly example.
..

A Transaction
=============

We have to commit the transaction for the dispatcher to see the job.

    >>> import transaction
    >>> transaction.commit()

A Result
========

Now wait a second and then try this.  "transaction.begin" will sync up our
database with database changes made elsewhere.

.. This lets us "wait a second".

    >>> import zc.async.testing
    >>> res = zc.async.testing.wait_for_result(j)

..

    >>> _ = transaction.begin()
    >>> j.result
    1216179006.856108
    >>> j.status
    u'completed-status'

Another Job
===========

You can also make closures by passing in the job class explicitly.  Generating
RSA keys is actually a reasonable real-world use case for something like this.

::

    >>  import subprocess
    >>  j = q.put(zc.async.job.Job(
    ...     subprocess.call,
    ...     ['openssl', 'genrsa', '-out',
    ...      'key.pem', '1024']))
    >>  transaction.commit()

Another Result
==============

::

    >>  j.result
    >>  _ = transaction.begin()
    >>  j.result
    0
    >>  subprocess.call(['cat', 'key.pem'])
    -----BEGIN RSA PRIVATE KEY-----
    MIICXgIBAAKBgQCYAZW+HjDGJhRHnUlZZWqhrGOxU2K/RhssmcMs0JLnWI2cWmZ+
    ...
    CEcz6ZbO8zm4AEGI/dqLicZh3bhunhflAovW6WxbNKLENQ==
    -----END RSA PRIVATE KEY-----
    0

Running Your Own Code
=====================

We've now seen some simple examples from the standard library.  But how do you
get your own work done?  How can you debug it?

Let's say we want to write a 

Picklable Callables and Arguments
=================================

You want a job to have a reference to your own callable, so the job will get
the work you define performed.

This reference, of the job to your callable, will need to be persisted in the
database.

Because zc.async uses the ZODB for its persistence mechanism, the ZODB's
persistence rules are in effect.

Luckily, these are fairly simple.

ZODB Persistence Rules
======================

- Anything pickleable can be persisted.  Module globals, such as functions,
  can be pickled, for instance, and will come in handy for our examples.

- Custom classes should typically inherit from persistent.Persistent.
  Instances of persistent.Persistent subclasses are each stored as a single
  record in the database, and references to them are handled efficiently.

- Use the transacton module to commit and abort transactions in the ZODB.

- For ZODB documentation see http://www.zope.org/Wikis/ZODB/guide/zodb.html

Make a File
===========

Make a new Python file.  Let's call it ``example.py``.



XXX
===

Next need to discuss that callables must be picklable, so we need to switch
from the interpreter to the filesystem.

Talk about callbacks, and how that lets you respond to results.

Talk briefly about failures, show the exceptions, and briefly mention logging
and debugging.

Start up multiple processes with dispatchers.

Close by referring to production instances needing something like zdaemon
or supervisor; and to preferring the more declarative zc.buildout style for
production...which we'll show in our next quickstart! ;-)

.. Now we are going to stop the reactor.

    >>> import zc.async.dispatcher
    >>> dispatcher = zc.async.dispatcher.get()
    >>> reactor = dispatcher.reactor
    >>> reactor.callFromThread(reactor.stop)
    >>> dispatcher.thread.join(3)
